## Providers and Signers

在构建智能合约的接口时，你通常会遇到这两个术语--提供者和签名者。虽然当你真正开始使用它们时，你会对它们有更好的理解，但我们将尝试对它们的含义做一个简单的解释。

我们知道，要向区块链读取或写入数据，我们需要通过一个以太坊节点进行通信。该节点包含区块链状态，允许我们读取数据。它也可以向矿工广播交易，让我们写数据。

请注意，在你想向区块链写入数据的情况下，节点只需要广播交易。因为如果你只是在读取已经存在的数据，矿工不需要做任何事情，他们已经完成了他们的工作。

提供者是一个以太坊节点连接，允许你从其状态中读取数据。你将使用提供者来做一些事情，如在智能合约中调用只读函数，获取账户余额，获取交易细节等。

签名者是一个以太坊节点连接，允许你向区块链写入数据。你将使用Signer来做一些事情，如在智能合约中调用写函数，在账户之间转移ETH等。要做到这一点，签名者需要访问一个私钥，它可以用来代表账户进行交易。

此外，签约人可以做提供者的一切。你可以使用签名者做这两件事，即读和写，但提供者只适合于读数据。

像Metamask这样的钱包，默认情况下，在你的浏览器中注入一个提供者。因此，dApps可以使用你的Metamask提供者，从你的钱包所连接的区块链网络中读取数值。

然而，有时候，你希望用户进行交易，而不仅仅是读取数据。当然，Metamask不能只是到处与随机网站分享你的私钥--那将是疯狂的。为此，Metamask还允许网站请求一个签名者。因此，当一个DApp试图向区块链发送交易时，Metamask窗口会弹出，要求用户确认该行动。

## BigNumbers

在学习Solidity时，我们经常阅读和使用uint256。uint256的范围从0到(2^256)-1。因此，uint256数据类型所能容纳的最大数字是天文数字般的大。

具体来说，uint256的最大值是：

115792089237316195423570985008687907853269984665640564039457584007913129639935

作为比较，一百万是

1000000

很明显，uint256可以容纳大得惊人的数字。但这也带来了一个问题。

我们通常用Javascript构建智能合约的接口。Javascript的数字数据类型的上限要小得多。

具体来说，Javascript能容纳的数字类型的最大值只是：

9007199254740991

这与uint256所能容纳的数值相差甚远!

所以，假设我们用Javascript在智能合约上调用一个函数，返回一个uint256。如果这个数字大于Javascript的最大数值，这绝对是可能的，那么会发生什么？

嗯，事实证明，Javascript不能支持这一点。因此，我们必须使用一种叫做BigNumber的特殊类型。用于与以太坊节点互动的库--ethers.js和web3.js--都支持BigNumbers。

BigNumber是一个自定义的类库，用Javascript编写，它为数学函数引入了自己的函数--add、sub、mul、div等。BigNumber的数字容量明显大于Javascript所能支持的。

当我们在下面的层次中写代码时，你会遇到通过调用.add()和.mul()等函数来完成数学运算，而不是我们所知道的典型的+和*运算符--这是因为当我们在处理BigNumbers时，需要使用它的数学函数。

至于如果我们试图用Javascript数字来做这件事会发生什么，我们会非常容易地溢出或不足。这意味着我们的计算将是完全不正确和不确定的。所以，请牢记这一点。

## ABI

ABI是指应用二进制接口。在与以太坊合作时，这是一个比较棘手的问题，但我们将尽可能地解释它。

当Solidity代码被编译时，它被编译成字节码，本质上是二进制的。它不包含合同中存在的函数名称的记录，它们包含什么参数，以及它们返回什么值。

然而，如果您想从 Web 应用程序中调用 Solidity 函数，您需要一种方法来调用合同中的正确字节码。要做到这一点，您需要一种方法，将人类可读的函数名称和参数转换为字节码，并返回。

ABI 正是帮助我们实现这一点。当您编译您的 Solidity 代码时，ABI 会由编译器自动生成。它包含合同中存在的函数的规则和元数据，这有助于进行适当的数据来回转换。

所以，当你想调用一个合约时，你需要它的地址（当然），但你也需要提供它的ABI。像ethers.js这样的库，在与以太坊节点通信和调用智能合约中的函数时，使用ABI将人类可读的函数编码和解码为字节码，并返回。

## ERC20 Approval Flow

在过去，我们学习了`payable`函数，它允许智能合约在调用一个函数时接受ETH付款。如果你想用ETH向用户收费以换取一些东西--例如NFT销售，这真的很有用。

但是，如果你想用ETH以外的东西来支付呢？如果你想使用你自己部署的加密货币进行支付呢？

这里的事情就有点棘手了。

由于ETH是以太坊的原生货币，而ERC20标准是在以太坊发明后很晚才引入的，它们的行为方式并不完全相同。具体来说，接受ERC20代币的支付并不像在Solidity中做一个函数支付那么简单。

payable这个关键词只适用于ETH的支付。如果你想使用你自己的ERC20加密货币，要做到这一点的流程就有点复杂了。

首先，让我们稍微思考一下。

好吧，所以你不能像使用ETH那样，将ERC20代币与函数调用一起发送。

- 也许智能合约可以以某种方式从函数调用者的账户中提取代币？
- 但这意味着我可以编写一个智能合约，如果有人用我的合约进行交易，就会窃取所有人的代币
- 所以我们需要一个更安全的方法来从某人的账户中提取代币
- 这就是批准和转移流程的作用。

ERC20标准有一个概念，就是Allowance。

![Image](https://i.imgur.com/jGlNcLH.png)

让我们试着借助一个例子来思考这个问题。

- 爱丽丝想出售她的NFT
- 爱丽丝想用她自己的加密货币AliceCoin来接受她的NFT的付款
- 爱丽丝的NFT成本为10个爱丽丝币
- 鲍勃拥有AliceCoin
- 鲍勃想购买爱丽丝的NFT
- Bob需要一种方法来调用Alice的NFT智能合约上的一个函数，它将接受10个Alicecoin的付款，并将他的NFT发送给他。
- 由于智能合约不能直接接受Alicecoin作为付款，Alice在她的NFT合约中编码了ERC20批准和转移流程

Alicecoin是一种ERC20代币。ERC20内置了一些与Allowance概念相关的功能。

`approve(address spender, uint256 amount)`
这允许用户批准一个不同的地址以他们的名义花费最高金额的代币，即该函数为花费者提供最高金额的津贴。

`transferFrom(address from, address to, uint256 amount)`
允许用户将金额代币从from转移到to。

如果调用该函数的用户与from地址相同，代币将从用户的余额中移除。

如果用户是来自地址以外的人，来自地址必须在过去给用户使用批准函数花费金额代币的许可。

现在继续看这个例子：

- 鲍勃给了爱丽丝的NFT合约，允许他使用批准函数花费最多10个他的Alicecoin
- 鲍勃调用函数来购买爱丽丝的NFT合约上的NFT
- 购买函数在内部调用了Alicecoin的transferFrom，并将10个Alicecoin从Bob的账户转移到Alice的账户中。
- 由于合同被Bob赋予了最多花费10个Alicecoin的权限，这个动作是被允许的。
- 因此，Alice收到了她的10个Alicecoin，而Bob收到了他的NFT

好吧，那么这对我们意味着什么呢？

好吧，请注意鲍勃必须给合同以批准，所以合同可以从他的账户中提取鲍勃的代币。

因此，Bob本质上不得不做两个交易，以复制在接受ETH支付的情况下可以在一个交易中完成的行为。

- 交易1 - 给予合约津贴
- 交易2 - 调用合约函数，该函数在内部使用津贴将鲍勃的代币转移到不同的地址。

因此，如果你正在建立一个dApp，你需要用户使用ERC20代币来支付你的智能合约，你也需要让他们做这两个交易。简单地调用你的合约函数，而不首先让你的用户向你的合约提供津贴，将导致函数调用失败。

在大二的最后一关建立DeFi-Exchange时，我们会遇到这种流程的用例。由于交易所涉及到能够将一个代币转换为另一个代币，你需要在交易所的智能合约上调用一个函数，该函数接收一个代币并给你另一个。

为了接收你的代币进行交换，交易所合同需要批准从你的账户中提取代币。

因此，如果你想知道为什么在交易所交换可以使用两个交易，而不是一个，请记住这个流程。